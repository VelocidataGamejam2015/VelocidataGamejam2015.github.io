<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
</head>
<body style="background-color: black;">
<canvas tabindex='1' id="canvas" width="1024" height="1024"></canvas>
<script>
    //#######################################################################
    // The game

    var canvas;
    var g_ctx;
    var canvas_width;
    var canvas_height;
    var g_cell_size;
    var current_screen;

    var mouse_x = 0;
    var mouse_y = 0;
    var mouse_click_pending = false;
    var key_code = 0;
    var key_press_pending = false;

    //--------------------------------------------------------------------------
    const GameConstants = {
        m_grid_size: 10,
        m_initial_monsters: 2,
        m_initial_cities: 3
    };

    //--------------------------------------------------------------------------
    const Util = {
        forEach: function (obj, fn)
        {
            var key;
            for (key in obj)
            {
                if (obj.hasOwnProperty(key))
                {
                    fn(obj[key]);
                }
            }
        },

        randomItem: function (arr)
        {
            return arr[Math.floor(Math.random() * arr.length)];
        }
    };
    //--------------------------------------------------------------------------

    //##########################################################################

    //--------------------------------------------------------------------------
    const LandTypes = {
        GRASS: {
            m_fill_style: "rgb(0, 255, 0)"
        },
        DIRT: {
            m_fill_style: "rgb(150, 75, 0)"
        },
        TREES: {
            m_fill_style: "rgb(0, 128, 0)"
        },
        ROCKS: {
            m_fill_style: "rgb(128, 128, 128)"
        },
        WATER: {
            m_fill_style: "rgb(128, 128, 255)"
        }
    };
    const ALL_LAND_TYPES = [];
    Util.forEach(LandTypes, function(item) { ALL_LAND_TYPES.push(item); } );

    //--------------------------------------------------------------------------
    var Land = function (land_type, grid_x, grid_y)
    {
        this.m_type = land_type;
        this.m_grid_x = grid_x;
        this.m_grid_y = grid_y;

        //----------------------------------------------------------------------
        /** Returns true if the click was handled. */
        this.handleMouseClick = function ()
        {
            return false;
        };

        //----------------------------------------------------------------------
        this.paint = function ()
        {
            g_ctx.fillStyle = this.m_type.m_fill_style;
            g_ctx.fillRect(
                    this.m_grid_x * g_cell_size, this.m_grid_y * g_cell_size,
                    g_cell_size, g_cell_size);
        };
    };

    //##########################################################################

    //--------------------------------------------------------------------------
    const MonsterTypes = {
        GLUTTONY: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/S_GluttonousTomato.png"
        },
        LUST: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/LustyCarrot.png"
        },
        GREED: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/RedMonster.png"
        },
        PRIDE: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/RedMonster.png"
        },
        WRATH: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/RedMonster.png"
        },
        ENVY: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/RedMonster.png"
        },
        SLOTH: {
            m_fill_style: "rgb(255, 127, 0)",
            m_image_source_file: "Assets/Monsters/RedMonster.png"
        }
    };
    const ALL_MONSTER_TYPES = [];
    Util.forEach(MonsterTypes, function(item) { ALL_MONSTER_TYPES.push(item); } );

    //--------------------------------------------------------------------------
    var Monster = function (monster_type, grid_x, grid_y)
    {
        this.m_type = monster_type;
        this.m_grid_x = grid_x;
        this.m_grid_y = grid_y;

        this.m_image = new Image();
        this.m_ready = false;
        this.m_image.src = this.m_type.m_image_source_file;
        this.m_loop = 0;

        //----------------------------------------------------------------------
        /** Returns true if the click was handled. */
        this.handleMouseClick = function() {
            if (!isMouseClickInCell(this.m_grid_x, this.m_grid_y))
            {
                return false;
            }
            this.m_state = (this.m_state + 1) % 2;
            return true;
        };

        //----------------------------------------------------------------------
        this.paint = function () {
            this.m_loop = (this.m_loop + 1) % 50;
            var diff = this.m_loop / 5;
            if (diff > 5)
            {
                diff = 10 - diff
            }
            g_ctx.drawImage
            (
                this.m_image,
                this.m_grid_x * g_cell_size + diff,
                this.m_grid_y * g_cell_size + diff,
                g_cell_size - diff * 2,
                g_cell_size - diff * 2
            );

            // g_ctx.fillStyle = this.m_type.m_fill_style;
            // g_ctx.fillRect(this.m_grid_x * g_cell_size, this.m_grid_y * g_cell_size, g_cell_size, g_cell_size);
        };
    };

    //##########################################################################

    //--------------------------------------------------------------------------
    const CityTypes = {
        BLUE: {
            m_fill_style: "rgb(100, 100, 255)"
        },
        RED: {
            m_fill_style: "rgb(255, 100, 100)"
        }
    };
    const ALL_CITY_TYPES = [];
    Util.forEach(CityTypes, function(item) { ALL_CITY_TYPES.push(item); } );

    //--------------------------------------------------------------------------
    var City = function (city_type, grid_x, grid_y)
    {
        this.m_type = city_type;
        this.m_grid_x = grid_x;
        this.m_grid_y = grid_y;

        //----------------------------------------------------------------------
        /** Returns true if the click was handled. */
        this.handleMouseClick = function ()
        {
            return false;
        };

        //----------------------------------------------------------------------
        this.paint = function ()
        {
            g_ctx.fillStyle = this.m_type.m_fill_style;
            g_ctx.fillRect(this.m_grid_x * g_cell_size, this.m_grid_y
                    * g_cell_size, g_cell_size, g_cell_size);
        };
    };

    //##########################################################################

    var g_game_state;

    //--------------------------------------------------------------------------
    function initGameState()
    {
        g_game_state = {};
        var grid_x, grid_y;

        // initialize land
        g_game_state.m_land = [];
        for (grid_x = 0; grid_x < GameConstants.m_grid_size; ++grid_x)
        {
            g_game_state.m_land[grid_x] = [];
            for (grid_y = 0; grid_y < GameConstants.m_grid_size; ++grid_y)
            {
                g_game_state.m_land[grid_x][grid_y]
                        = new Land(Util.randomItem(ALL_LAND_TYPES), grid_x, grid_y);
            }
        }

        // initialize monsters
        g_game_state.m_monsters = [];
        var monster_index;
        for (monster_index = 0;
             monster_index < GameConstants.m_initial_monsters;
             ++monster_index)
        {
            grid_x = Math.floor(Math.random() * GameConstants.m_grid_size);
            grid_y = Math.floor(Math.random() * GameConstants.m_grid_size);
            g_game_state.m_monsters[monster_index]
                = new Monster(Util.randomItem(ALL_MONSTER_TYPES), grid_x, grid_y);
        }

        // initialize cities
        g_game_state.m_cities = [];
        var city_index;
        for (city_index = 0;
            city_index < GameConstants.m_initial_cities;
            ++city_index)
        {
            grid_x = Math.floor(Math.random() * GameConstants.m_grid_size);
            grid_y = Math.floor(Math.random() * GameConstants.m_grid_size);
            g_game_state.m_cities[city_index]
                = new City(Util.randomItem(ALL_CITY_TYPES), grid_x, grid_y);
        }
    }

    //##########################################################################

    //--------------------------------------------------------------------------
    function init() {
        //Canvas stuff
        canvas = $("#canvas")[0];
        g_ctx = canvas.getContext("2d");
        canvas_width = $("#canvas").width();
        canvas_height = $("#canvas").height();
        g_ctx.textAlign = "center";
        g_ctx.textBaseline = "middle";

        //Lets save the cell width in a variable for easy control
        g_cell_size = canvas_height / GameConstants.m_grid_size;

        canvas.addEventListener("mousedown", function (event) {
            var rect = canvas.getBoundingClientRect();
            mouse_x = event.clientX - rect.left;
            mouse_y = event.clientY - rect.top;
            mouse_click_pending = true;
        }, false);

        canvas.addEventListener("keydown", function (event) {
            key_code = event.which;
            key_press_pending = true;
        }, false);

        //can't do this until you've set up canvas_width and canvas_height
        GameScreen.init();
        GameScreen.reset();
        current_screen = GameScreen;

        // start processing events
        setTimeout(eventLoop, 40);
    }

    //--------------------------------------------------------------------------
    var isMouseClickInCell = function (grid_x, grid_y) {
        return (mouse_x >= grid_x * g_cell_size
        && mouse_x < (grid_x + 1) * g_cell_size
        && mouse_y >= grid_y * g_cell_size
        && mouse_y < (grid_y +1) * g_cell_size);
    };

    //--------------------------------------------------------------------------
    var GameScreen = {

        //----------------------------------------------------------------------
        init: function ()
        {
            initGameState()
        },

        //-------------------------------------------------------------------
        reset: function ()
        {
        },

        //-------------------------------------------------------------------
        handleMouseClick: function ()
        {

//            for (m in this.monsters)
//            {
//                this.monsters[m].handleMouseClick();
//            }
        },

        //-------------------------------------------------------------------
        handleKeyPress: function ()
        {
        },

        //-------------------------------------------------------------------
        paint: function ()
        {
            g_ctx.setTransform(1, 0, 0, 1, 0, 0);

            // paint the land
            var grid_x, grid_y;
            for (grid_x = 0; grid_x < GameConstants.m_grid_size; ++grid_x)
            {
                for (grid_y = 0; grid_y < GameConstants.m_grid_size; ++grid_y)
                {
                    g_game_state.m_land[grid_x][grid_y].paint();
                }
            }

            Util.forEach(g_game_state.m_monsters, function(monster){
                monster.paint();
            })
        }
    };

    //--------------------------------------------------------------------------
    var TitleScreen = {

        scratches: [],
        monsters: [],
        countdown: 1,
        text: "game goes here",
        default_text: "game goes here",
        text1: "w",
        second_countdown_timer: {active: true, period: 25, current: 0},
        circle: {active: false, x: 0, y: 0},


        //----------------------------------------------------------------------
        init: function () {
            this.scratches.push({x_top: 30, x_stray: -5, age: 0, active: 100, period: 170});
            this.scratches.push({x_top: 120, x_stray: 5, age: 0, active: 150, period: 190});
            this.monsters.push(new Monster(MonsterTypes.ENVY, 1, 1));
            g_ctx.textAlign = "center";
            g_ctx.textBaseline = "middle";

            this.size_upper = g_ctx.measureText(this.text1).width;
        },

        //-------------------------------------------------------------------
        reset: function () {
            g_ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.scratches[0].x_top = 30;
            this.scratches[0].x_stray = -5;
            this.scratches[0].age = 0;
            this.scratches[0].active = 100;
            this.scratches[0].period = 170;
            this.scratches[1].x_top = 120;
            this.scratches[1].x_stray = 5;
            this.scratches[1].age = 0;
            this.scratches[1].active = 150;
            this.scratches[1].period = 190;
            this.second_countdown_timer.active = true;
            this.second_countdown_timer.current = 0;
            this.countdown = 1;
            this.circle.active = false;
            this.circle.x = 0;
            this.circle.y = 0;
        },

        //-------------------------------------------------------------------
        handleMouseClick: function () {
            this.circle.active = true;
            this.circle.x = mouse_x;
            this.circle.y = mouse_y;

            for (m in this.monsters)
            {
                this.monsters[m].handleMouseClick();
            }
        },

        //-------------------------------------------------------------------
        handleKeyPress: function () {
            this.text = key_code;
        },

        //-------------------------------------------------------------------
        paint: function () {
            //Lets paint the canvas now
            //set up blank canvas
            g_ctx.fillStyle = "white";
            g_ctx.fillRect(0, 0, canvas_width, canvas_height);

            //start jitter
            jiggle_x = Math.random() * 1;
            jiggle_y = Math.random() * 1;
            g_ctx.setTransform(1, 0, 0, 1, jiggle_x, jiggle_y);

            g_ctx.lineWidth = 5;
            g_ctx.strokeStyle = "rgb(0, 0, 0)";
            g_ctx.fillStyle = "rgb(128, 128, 128)";

            if (this.circle.active) {
                g_ctx.beginPath();
                g_ctx.arc(this.circle.x, this.circle.y, 20, 0, 2 * Math.PI);
                g_ctx.stroke();
            }

            if (this.second_countdown_timer.active) {
                this.second_countdown_timer.current++;
                if (this.second_countdown_timer.current >= this.second_countdown_timer.period) {
                    this.second_countdown_timer.current = 0;
                    this.countdown--;
                    if (this.countdown == 0) {
                        this.countdown = 1;
                        this.second_countdown_timer.active = false;
                    }
                }


                g_ctx.beginPath();
                g_ctx.moveTo(canvas_width / 2, canvas_height / 2);
                g_ctx.lineTo(canvas_width / 2, -canvas_height / 2);
                var percent_covered = 1.5 + 2 * this.second_countdown_timer.current / this.second_countdown_timer.period;
                g_ctx.arc(canvas_width / 2, canvas_height / 2, canvas_height, 1.5 * Math.PI, percent_covered * Math.PI);
                g_ctx.closePath();
                g_ctx.fill();
                g_ctx.beginPath();
                g_ctx.moveTo(canvas_width / 2, canvas_height / 2);
                g_ctx.lineTo(canvas_width / 2, -canvas_height / 2);
                var percent_covered = 1.5 + 2 * this.second_countdown_timer.current / this.second_countdown_timer.period;
                g_ctx.arc(canvas_width / 2, canvas_height / 2, canvas_height, 1.5 * Math.PI, percent_covered * Math.PI);
                g_ctx.closePath();
                g_ctx.stroke();

                g_ctx.beginPath();
                g_ctx.moveTo(0, canvas_height / 2);
                g_ctx.lineTo(canvas_width, canvas_height / 2);
                g_ctx.stroke();
                g_ctx.beginPath();
                g_ctx.moveTo(canvas_width / 2, 0);
                g_ctx.lineTo(canvas_width / 2, canvas_height);
                g_ctx.stroke();

                g_ctx.beginPath();
                g_ctx.arc(canvas_width / 2, canvas_height / 2, 450, 0, 2 * Math.PI);
                g_ctx.arc(canvas_width / 2, canvas_height / 2, 500, 0, 2 * Math.PI);
                g_ctx.stroke();

                g_ctx.font = "800px Arial";
                g_ctx.fillStyle = "rgb(0, 0, 0)";
                g_ctx.textAlign = "center";
                g_ctx.textBaseline = "middle";
                g_ctx.fillText(this.countdown, canvas_width / 2, canvas_height / 2);
            }
            else {
                g_ctx.fillStyle = "rgb(0,0,0)";
                g_ctx.font = "Bold 80px Arial";
                g_ctx.fillText(this.text, canvas_width / 2, canvas_height / 2);
                for(var m in this.monsters)
                {
                    this.monsters[m].paint();
                }
            }

            //finish jitter
            g_ctx.lineWidth = 5;
            g_ctx.strokeStyle = "rgb(0, 0, 0)";
            g_ctx.fillStyle = "rgb(128, 128, 128)";

            g_ctx.setTransform(1, 0, 0, 1, 0, 0);
            g_ctx.fillStyle = "rgb(0, 0, 0)";
            g_ctx.globalAlpha = 0.25;
            if (Math.random() < .15) {
                g_ctx.globalAlpha = 0.35;
            }
            g_ctx.strokeStyle = "rgb(196, 196, 196)";
            g_ctx.fillSytle = g_ctx.strokeStyle;
            for (var j = 0; j < 1; j++) {
                g_ctx.beginPath();
                g_ctx.arc(Math.random() * canvas_height, Math.random() * canvas_height, 2, 0, 2 * Math.PI);
                g_ctx.fill();
            }
            g_ctx.lineWidth = 1;
            for (var j = 0; j < 2; j++) {
                this.scratches[j].age++;
                if (this.scratches[j].age >= this.scratches[j].period) {
                    this.scratches[j].age = 0;
                    this.scratches[j].x_top = Math.random() * canvas_width;
                    this.scratches[j].x_stray = Math.random() * 9 - 4.5;
                }
                if (this.scratches[j].age < this.scratches[j].active && this.scratches[j].age % 10 != 0) {
                    g_ctx.beginPath();
                    g_ctx.moveTo(this.scratches[j].x_top, 0);
                    g_ctx.lineTo(this.scratches[j].x_top + this.scratches[j].x_stray, canvas_height);
                    this.scratches[j].x_top += Math.random() * 7 - 3.5;
                    this.scratches[j].x_stray += Math.random() * 2 - 1;
                    g_ctx.stroke();
                }
            }
            g_ctx.fillStyle = "rgb(0, 0, 0)";
            g_ctx.fillRect(0, 0, canvas_width, canvas_height);
            g_ctx.globalAlpha = 1;
        }
    };

    //--------------------------------------------------------------------------
    function eventLoop() {
        var start_time = Date.now();

        if (mouse_click_pending) {
            mouse_click_pending = false;
            current_screen.handleMouseClick();
        }

        if (key_press_pending) {
            key_press_pending = false;
            current_screen.handleKeyPress();
        }
        current_screen.paint();

        var end_time = Date.now();
        var comp_time = end_time - start_time;
        if (comp_time > 40 || comp_time < 0) {
            setTimeout(eventLoop, 0);
        }
        else {
            setTimeout(eventLoop, 40 - comp_time);
        }

    }

    // launch the game once the document is fully loaded
    $(document).ready(init);

</script>
</body>
</html>
